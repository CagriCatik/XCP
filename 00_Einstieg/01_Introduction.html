<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Einführung</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../00_Einstieg/index.html"><strong aria-hidden="true">1.</strong> Einstieg</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../00_Einstieg/01_Introduction.html" class="active"><strong aria-hidden="true">1.1.</strong> Einführung</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/02_Polling.html"><strong aria-hidden="true">1.2.</strong> Polling</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/03_Synchronous_Data_Aquisition.html"><strong aria-hidden="true">1.3.</strong> Synchronous Data Aquisition</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/04_Performance_Analysis.html"><strong aria-hidden="true">1.4.</strong> Performance Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../01_Grundlagen/index.html"><strong aria-hidden="true">2.</strong> Grundlagen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_Grundlagen/01_xcp-kommunikationsprotokoll.html"><strong aria-hidden="true">2.1.</strong> XCP Kommunikationsprotokoll</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/02_xcp-protokollschicht.html"><strong aria-hidden="true">2.2.</strong> XCP Protokollschicht</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/03_austausch-cto.html"><strong aria-hidden="true">2.3.</strong> Austausch CTO</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/04_austausch_dto.html"><strong aria-hidden="true">2.4.</strong> Austausch DTO</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/05_zeit-korrelation.html"><strong aria-hidden="true">2.5.</strong> Zeit Korrelation</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/06_xcp-transportschichten.html"><strong aria-hidden="true">2.6.</strong> XCP Transportschichten</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/07_xcp-services.html"><strong aria-hidden="true">2.7.</strong> XCP Services</a></li></ol></li><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/index.html"><strong aria-hidden="true">3.</strong> Beschreibung von A2L</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/01_aufbau-a2l.html"><strong aria-hidden="true">3.1.</strong> Aufbau der A2L</a></li><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/02_manuelle-a2l-erstellung.html"><strong aria-hidden="true">3.2.</strong> Manuelle A2L Erstellung</a></li></ol></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/index.html"><strong aria-hidden="true">4.</strong> Kalibrierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/01_parameter-flash.html"><strong aria-hidden="true">4.1.</strong> Parameter Flash</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/02_paremeter-ram.html"><strong aria-hidden="true">4.2.</strong> Parameter RAM</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/03_flash-overlay.html"><strong aria-hidden="true">4.3.</strong> Flash Overlay</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/04_dynamic-flash-overlay.html"><strong aria-hidden="true">4.4.</strong> Dynamic Flash Overlay</a></li></ol></li><li class="chapter-item expanded "><a href="../04_Tooling/index.html"><strong aria-hidden="true">5.</strong> Tooling</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-xcp"><a class="header" href="#introduction-to-xcp">Introduction to XCP</a></h1>
<p>XCP, das Universal Measurement and Calibration Protocol, ist ein standardisiertes Protokoll, das in der Automobiltechnik für die effiziente Messung und Kalibrierung von elektronischen Steuergeräten (ECUs) verwendet wird. Dieses Kapitel dient als einführender Leitfaden für die Grundlagen von XCP und erkundet seine Anwendungsfälle, Nachrichtenstruktur und praktischen Anwendungen. XCP erleichtert die Messung und Kalibrierung von Daten innerhalb von ECUs und ermöglicht Ingenieuren die Interaktion und Modifikation von Parametern für optimale Leistung. Zu den häufigen Aufgaben gehören:</p>
<ul>
<li><strong>Datenerfassung</strong> : Erfassung von Echtzeitdaten aus ECUs zur Analyse und Überwachung.</li>
<li><strong>Kalibrierung</strong> : Anpassung von ECU-Parametern zur Optimierung von Leistung, Kraftstoffeffizienz, Emissionen usw.</li>
</ul>
<h4 id="struktur-von-xcp-nachrichten"><a class="header" href="#struktur-von-xcp-nachrichten">Struktur von XCP-Nachrichten</a></h4>
<p>Die XCP-Kommunikation dreht sich um Nachrichten, die zwischen einem Master (z. B. Kalibrierungswerkzeug) und einem Slave (ECU) ausgetauscht werden. Diese Nachrichten bestehen aus Anfragen und Antworten, die über Kommunikationsnetze wie den CAN-Bus übertragen werden. Wesentliche Bestandteile einer XCP-Nachricht sind:</p>
<ul>
<li><strong>Paketkennung (PID)</strong> : Das erste Byte eines XCP-Pakets, das den Befehlscodiert und die auszuführende Aktion bestimmt.</li>
<li><strong>Datenfeld</strong> : Enthält Informationen, die für die Ausführung des Befehls erforderlich sind, wie Speicheradressen, Datenwerte usw.</li>
</ul>
<p>Die bereitgestellte Übung veranschaulicht einen Kalibrierungsprozess, der über XCP-Befehle durchgeführt wird. Es umfasst:</p>
<div class="table-wrapper"><table><thead><tr><th>Time</th><th>Name</th><th>Dir</th><th>Len</th><th>Data</th><th>Command</th></tr></thead><tbody>
<tr><td>35.84s</td><td>CMD</td><td>Tx</td><td>8</td><td><strong>f6</strong> 01 09 00 96 00 00 00</td><td>SET_MTA</td></tr>
<tr><td>36.01s</td><td>RES</td><td>Rx</td><td>1</td><td><strong>ff</strong></td><td>POS_ACK</td></tr>
<tr><td>36.01s</td><td>CMD</td><td>Tx</td><td>3</td><td><strong>f0</strong> 01 0a</td><td>DOWNLOAD</td></tr>
<tr><td>36.01s</td><td>RES</td><td>Rx</td><td>1</td><td><strong>ff</strong></td><td>POS_ACK</td></tr>
<tr><td>36.07s</td><td>CMD</td><td>Tx</td><td>8</td><td><strong>f4</strong> 01 0a 00 96 00 00 00</td><td>SHORT_UPLOAD</td></tr>
<tr><td>36.07s</td><td>RES</td><td>Rx</td><td>2</td><td><strong>ff</strong> 0a</td><td>POS_ACK</td></tr>
</tbody></table>
</div>
<p>Die Sequenz von XCP-Befehlen aus der Übung stellt einen realen Kalibrierungsprozess in einem CANape-Kalibrierfenster dar. Der Kalibrierungsprozess wird mit einem SET_MTA-Befehl (PID: 0xf6) initiiert. Der Befehl setzt den Speicherzugriffspointer des XCP-Slaves auf die in dem Befehl angegebene Adresse. In unserem Fall wird der Speicherzugriffspointer auf die Adresse 0x00 00 00 96 gesetzt. Nach Erhalt der positiven Antwort auf den SET_MTA-Befehl verwendet der Master einen DOWNLOAD-Befehl (PID: 0xf0), um Daten zu schreiben (in unserem Fall den Wert 0x0A, 1 Byte) in den Speicher des Slaves. Die Daten werden in die Speicherzellen geschrieben, die durch den Speicheradresspointer markiert sind.</p>
<p>Interessanterweise beendet der Master den Kalibrierungsprozess, indem er den Wert der geänderten Speicherzellen mit einem SHORT_UPLOAD-Befehl (PID: 0xf4) zurückliest. Der SHORT_UPLOAD-Befehl wird die Startadresse (0x00 00 00 96) und die Länge der auszulesenden Speicherzellen (1 Byte) enthalten. Der SHORT_UPLOAD-Befehl wird auch verwendet, um kontinuierlich einzelne Werte aus dem Steuergerät auszulesen, wie wir im nächsten Kapitel besprechen werden, das sich mit den verfügbaren Messmodi über XCP beschäftigt.</p>
<p>Im XCP-Protokoll wird jeder Befehl durch einen spezifischen Befehlscode identifiziert, der als erstes Byte eines XCP-Pakets übertragen wird, das als Paketkennung (PID) bekannt ist. Diese Befehlscodes werden durch die ASAM-Spezifikation des XCP-Protokolls standardisiert. Im Folgenden finden Sie eine Tabelle mit einer Reihe von XCP-Befehlen sowie ihren entsprechenden Befehlscodes. Durch Analyse des ersten Bytes jedes XCP-Pakets können Sie die entsprechenden XCP-Befehle identifizieren, wie in der Tabelle aufgeführt.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Command</th><th>Command Code</th></tr></thead><tbody>
<tr><td style="text-align: left">GET_STATUS</td><td>0xFD</td></tr>
<tr><td style="text-align: left">SYNCH</td><td>0xFC</td></tr>
<tr><td style="text-align: left">GET_COMM_MODE_INFO</td><td>0xFB</td></tr>
<tr><td style="text-align: left">GET_ID</td><td>0xFA</td></tr>
<tr><td style="text-align: left">SET_REQUEST</td><td>0xF9</td></tr>
<tr><td style="text-align: left">GET_SEED</td><td>0xF8</td></tr>
<tr><td style="text-align: left">UNLOCK</td><td>0xF7</td></tr>
<tr><td style="text-align: left">SET_MTA</td><td>0xF6</td></tr>
<tr><td style="text-align: left">UPLOAD</td><td>0xF5</td></tr>
<tr><td style="text-align: left">SHORT_UPLOAD</td><td>0xF4</td></tr>
<tr><td style="text-align: left">BUILD_CHECKSUM</td><td>0xF3</td></tr>
<tr><td style="text-align: left">TRANSPORT_LAYER_CMD</td><td>0xF2</td></tr>
<tr><td style="text-align: left">USER_CMD</td><td>0xF1</td></tr>
<tr><td style="text-align: left">DOWNLOAD</td><td>0xF0</td></tr>
<tr><td style="text-align: left">POS_ACK (RES)</td><td>0xFF</td></tr>
<tr><td style="text-align: left">ERR</td><td>0xFE</td></tr>
</tbody></table>
</div>
<p>Durch Bezugnahme auf diese Tabelle können Sie leicht den verwendeten XCP-Befehl in einem bestimmten XCP-Paket bestimmen, indem Sie den Wert des ersten Bytes analysieren, der den Befehlscode darstellt. Hier sind die Erklärungen für jeden Befehl im Zusammenhang mit dem XCP-Protokoll:</p>
<ol>
<li>
<p><strong>GET_STATUS (Status abrufen)</strong> (Befehlscode: 0xFD):</p>
<ul>
<li>Dieser Befehl wird verwendet, um den Status des ECU-Slave-Geräts abzurufen, einschließlich Informationen über seinen aktuellen Zustand und Betriebsmodus.</li>
</ul>
</li>
<li>
<p><strong>SYNCH (Synchronisation)</strong> (Befehlscode: 0xFC):</p>
<ul>
<li>Der SYNCH-Befehl wird verwendet, um die Kommunikation zwischen dem Master und dem Slave zu synchronisieren, insbesondere nach einem möglichen Kommunikationsverlust oder nach einem Systemneustart.</li>
</ul>
</li>
<li>
<p><strong>GET_COMM_MODE_INFO (Kommunikationsmodusinformationen abrufen)</strong> (Befehlscode: 0xFB):</p>
<ul>
<li>Mit diesem Befehl können Informationen über die verfügbaren Kommunikationsmodi zwischen dem Master und dem Slave abgerufen werden, einschließlich der unterstützten Übertragungsraten und anderer relevanter Parameter.</li>
</ul>
</li>
<li>
<p><strong>GET_ID (ID abrufen)</strong> (Befehlscode: 0xFA):</p>
<ul>
<li>Der GET_ID-Befehl wird verwendet, um die eindeutige Kennung des Slaves abzurufen, die oft zur Identifizierung des Geräts in einem Netzwerk verwendet wird.</li>
</ul>
</li>
<li>
<p><strong>SET_REQUEST (Anforderung einstellen)</strong> (Befehlscode: 0xF9):</p>
<ul>
<li>Dieser Befehl wird verwendet, um spezifische Anfragen oder Anforderungen an den Slave zu senden, die eine bestimmte Aktion auslösen sollen, wie z.B. das Lesen oder Schreiben von Daten.</li>
</ul>
</li>
<li>
<p><strong>GET_SEED (Seed abrufen)</strong> (Befehlscode: 0xF8):</p>
<ul>
<li>Mit diesem Befehl wird ein Seed-Wert vom Slave abgerufen, der für Authentifizierungszwecke verwendet werden kann, insbesondere wenn Sicherheitsmechanismen wie Seed &amp; Key implementiert sind.</li>
</ul>
</li>
<li>
<p><strong>UNLOCK (Entsperren)</strong> (Befehlscode: 0xF7):</p>
<ul>
<li>Der UNLOCK-Befehl wird verwendet, um den Slave zu entsperren, wenn bestimmte Zugriffsbeschränkungen oder Sicherheitsmechanismen aktiviert sind.</li>
</ul>
</li>
<li>
<p><strong>SET_MTA (Memory-Transfer-Adresse einstellen)</strong> (Befehlscode: 0xF6):</p>
<ul>
<li>SET_MTA wird verwendet, um den Speicherzugriffspointer des Slaves auf eine bestimmte Adresse zu setzen, was oft der erste Schritt bei Kalibrierungs- oder Messvorgängen ist.</li>
</ul>
</li>
<li>
<p><strong>UPLOAD (Hochladen)</strong> (Befehlscode: 0xF5):</p>
<ul>
<li>Dieser Befehl wird verwendet, um Daten oder Informationen vom Slave zum Master hochzuladen, beispielsweise Messwerte oder Konfigurationsdaten.</li>
</ul>
</li>
<li>
<p><strong>SHORT_UPLOAD (Kurzes Hochladen)</strong> (Befehlscode: 0xF4):</p>
<ul>
<li>SHORT_UPLOAD ermöglicht das Hochladen einer begrenzten Anzahl von Daten vom Slave zum Master, was besonders nützlich ist, wenn nur kleine Datenmengen benötigt werden.</li>
</ul>
</li>
<li>
<p><strong>BUILD_CHECKSUM (Prüfsumme erstellen)</strong> (Befehlscode: 0xF3):</p>
<ul>
<li>Mit diesem Befehl kann eine Prüfsumme oder ein Prüfwert für bestimmte Daten im Slave-Gerät erstellt werden, um die Integrität der übertragenen Daten zu überprüfen.</li>
</ul>
</li>
<li>
<p><strong>TRANSPORT_LAYER_CMD (Transportebenen-Befehl)</strong> (Befehlscode: 0xF2):</p>
<ul>
<li>Dieser Befehl wird verwendet, um spezifische Befehle oder Aktionen auf der Transportebene durchzuführen, beispielsweise das Öffnen oder Schließen einer Kommunikationsverbindung.</li>
</ul>
</li>
<li>
<p><strong>USER_CMD (Benutzerbefehl)</strong> (Befehlscode: 0xF1):</p>
<ul>
<li>USER_CMD ermöglicht die Übertragung benutzerdefinierter Befehle oder Aktionen zwischen Master und Slave, die nicht durch Standard-XCP-Befehle abgedeckt sind.</li>
</ul>
</li>
<li>
<p><strong>DOWNLOAD (Herunterladen)</strong> (Befehlscode: 0xF0):</p>
<ul>
<li>Dieser Befehl wird verwendet, um Daten oder Konfigurationsinformationen vom Master zum Slave zu übertragen, beispielsweise Kalibrierungsparameter oder Software-Updates.</li>
</ul>
</li>
<li>
<p><strong>POS_ACK (Positive Bestätigung) (RES)</strong> (Befehlscode: 0xFF):</p>
<ul>
<li>POS_ACK ist eine positive Bestätigungsnachricht vom Slave an den Master, um den Empfang und die Verarbeitung eines Befehls zu bestätigen.</li>
</ul>
</li>
<li>
<p><strong>ERR (Fehler)</strong> (Befehlscode: 0xFE):</p>
<ul>
<li>ERR ist eine Fehlermeldung vom Slave an den Master, die darauf hinweist, dass ein Befehl nicht erfolgreich verarbeitet werden konnte oder ein Problem aufgetreten ist.</li>
</ul>
</li>
</ol>
<p>XCP-Anfragen, wie der SHORT_UPLOAD-Befehl, können verwendet werden, um bestimmte Zellen des internen Speichers eines Steuergeräts zu lesen. Diese Befehle werden verwendet, um Signale direkt aus dem internen Speicher zu messen, wie Sie im zweiten Kapitel erfahren werden. Andererseits können Daten auch in den internen Speicher zurückgeschrieben werden, z. B. durch Verwendung eines DOWNLOAD-Befehls.</p>
<p>XCP-Verbindungen sind Punkt-zu-Punkt-Verbindungen zwischen einem Master (z. B. einem Mess- und Kalibrierungswerkzeug wie CANape) und einem Slave (dem XCP-Treiber eines Steuergeräts). Die Kommunikation wird immer vom Master hergestellt. Der Master sendet einen XCP-Befehl im Datenfeld eines Transportebenenrahmens des vorhandenen Netzwerks. Der Typ des Befehls wird als erstes Byte der XCP-Nachricht als Paketkennung (PID) übertragen. Die folgenden Bytes der Nachricht enthalten Informationen, die vom Slave zur Ausführung des Befehls benötigt werden. Z. B. eine Adresse und die Anzahl der vom Slave auszulesenden Speicherzellen. Der XCP-Slave antwortet entweder mit einer positiven Antwort oder einer negativen Antwort. Eine positive Antwort kann zusätzliche Daten enthalten, z. B. die angeforderten Informationen. Eine negative Antwort trägt einen Fehlercode.</p>
<p>Die PID und Struktur von XCP-Befehlen und deren Antworten sind in der ASAM-Spezifikation des XCP-Protokolls beschrieben. Das Protokoll beschreibt auch die Struktur von XCP-Rahmen in einem CAN-, FlexRay-, Ethernet-Netzwerk usw. Mess- und Kalibrierungsaufgaben werden unter Verwendung derselben XCP-Befehle in verschiedenen Transportebenen implementiert. Lediglich die Transportebenenrahmen, die die entsprechenden XCP-Befehle tragen, werden sich ändern.</p>
<p>Im Fall von XCP über CAN kommuniziert jedes Master-Slave-Paar mit einem festen Satz von IDs, z. B. verwendet CANape die CAN-ID 200 und das Steuergerät die CAN-ID 201 für ihre XCP-Kommunikation. Falls ein zweites Master-Slave-Paar existiert, werden eine andere Reihe von festen CAN-IDs verwendet.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../00_Einstieg/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../00_Einstieg/02_Polling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../00_Einstieg/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../00_Einstieg/02_Polling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
