<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Polling</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../00_Einstieg/index.html"><strong aria-hidden="true">1.</strong> Einstieg</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../00_Einstieg/01_Introduction.html"><strong aria-hidden="true">1.1.</strong> Einführung</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/02_Polling.html" class="active"><strong aria-hidden="true">1.2.</strong> Polling</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/03_Synchronous_Data_Aquisition.html"><strong aria-hidden="true">1.3.</strong> Synchronous Data Aquisition</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/04_Performance_Analysis.html"><strong aria-hidden="true">1.4.</strong> Performance Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../01_Grundlagen/index.html"><strong aria-hidden="true">2.</strong> Grundlagen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_Grundlagen/01_xcp-kommunikationsprotokoll.html"><strong aria-hidden="true">2.1.</strong> XCP Kommunikationsprotokoll</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/02_xcp-protokollschicht.html"><strong aria-hidden="true">2.2.</strong> XCP Protokollschicht</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/03_austausch-cto.html"><strong aria-hidden="true">2.3.</strong> Austausch CTO</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/04_austausch_dto.html"><strong aria-hidden="true">2.4.</strong> Austausch DTO</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/05_zeit-korrelation.html"><strong aria-hidden="true">2.5.</strong> Zeit Korrelation</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/06_xcp-transportschichten.html"><strong aria-hidden="true">2.6.</strong> XCP Transportschichten</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/07_xcp-services.html"><strong aria-hidden="true">2.7.</strong> XCP Services</a></li></ol></li><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/index.html"><strong aria-hidden="true">3.</strong> Beschreibung von A2L</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/01_aufbau-a2l.html"><strong aria-hidden="true">3.1.</strong> Aufbau der A2L</a></li><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/02_manuelle-a2l-erstellung.html"><strong aria-hidden="true">3.2.</strong> Manuelle A2L Erstellung</a></li></ol></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/index.html"><strong aria-hidden="true">4.</strong> Kalibrierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/01_parameter-flash.html"><strong aria-hidden="true">4.1.</strong> Parameter Flash</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/02_parameter-ram.html"><strong aria-hidden="true">4.2.</strong> Parameter RAM</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/03_flash-overlay.html"><strong aria-hidden="true">4.3.</strong> Flash Overlay</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/04_dynamic-flash-overlay.html"><strong aria-hidden="true">4.4.</strong> Dynamic Flash Overlay</a></li></ol></li><li class="chapter-item expanded "><a href="../04_Tooling/index.html"><strong aria-hidden="true">5.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04_Tooling/01_Messen_Auswerten.html"><strong aria-hidden="true">5.1.</strong> Messen & Auswerten</a></li><li class="chapter-item expanded "><a href="../04_Tooling/02_Kalibrieren_Verwalten.html"><strong aria-hidden="true">5.2.</strong> Kalibrieren & Verwalten</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="polling"><a class="header" href="#polling">Polling</a></h1>
<p>XCP (Universal Measurement and Calibration Protocol) bietet zwei grundlegende Messmodi: den <strong>Polling-Modus</strong> und den <strong>Synchronen Datenerfassungsmodus</strong> (kurz <strong>DAQ-Modus</strong>). Diese Modi ermöglichen es Entwicklern und Ingenieuren, Fahrzeugdaten effizient zu erfassen und zu analysieren, um die Leistung und Funktionalität von Steuergeräten zu optimieren.</p>
<h2 id="auswahl-des-messmodus-in-canape"><a class="header" href="#auswahl-des-messmodus-in-canape">Auswahl des Messmodus in CANape</a></h2>
<p>Der CANape-Benutzer hat die Flexibilität, den bevorzugten Messmodus innerhalb der Messkonfiguration von CANape auszuwählen. Diese Auswahl hängt maßgeblich von den spezifischen Anforderungen des Projekts ab, einschließlich der Anzahl der zu messenden Signale, der erforderlichen Messgeschwindigkeit und der verfügbaren Systemressourcen.</p>
<h2 id="vertiefung-in-den-polling-modus"><a class="header" href="#vertiefung-in-den-polling-modus">Vertiefung in den Polling-Modus</a></h2>
<h3 id="implementierung-des-polling-modus"><a class="header" href="#implementierung-des-polling-modus">Implementierung des Polling-Modus</a></h3>
<p>Der <strong>Polling-Modus</strong> wird in XCP durch die Verwendung der Befehle <code>SHORT_UPLOAD</code> oder <code>UPLOAD</code> implementiert. Dieser Modus arbeitet, indem jedes angeforderte Signal einzeln aus dem Speicher des Steuergeräts gelesen wird. Die Abfrage erfolgt sequenziell, was bedeutet, dass jeder XCP-Befehl nacheinander verarbeitet wird. Ein Befehl muss vollständig verarbeitet und bestätigt werden, bevor der nächste Befehl vom Master gesendet werden kann.</p>
<h4 id="ablauf-der-kommunikation-im-polling-modus"><a class="header" href="#ablauf-der-kommunikation-im-polling-modus">Ablauf der Kommunikation im Polling-Modus</a></h4>
<ol>
<li><strong>Befehlsübermittlung:</strong> Der Master (z.B. CANape) sendet einen <code>SHORT_UPLOAD</code>- oder <code>UPLOAD</code>-Befehl an das Steuergerät, um den Wert eines spezifischen Signals anzufordern.</li>
<li><strong>Verarbeitung und Bestätigung:</strong> Das Steuergerät empfängt den Befehl, liest das angeforderte Signal aus dem Speicher und sendet eine entsprechende Bestätigung zurück.</li>
<li><strong>Nächster Befehl:</strong> Erst nach Erhalt der Bestätigung kann der Master den nächsten Befehl senden, um ein weiteres Signal abzurufen.</li>
</ol>
<h3 id="kommunikationsstruktur-und-buslast"><a class="header" href="#kommunikationsstruktur-und-buslast">Kommunikationsstruktur und Buslast</a></h3>
<p>Die sequenzielle Verarbeitung der XCP-Befehle hat direkte Auswirkungen auf die Kommunikationsstruktur und die Auslastung des Busses:</p>
<ul>
<li>
<p><strong>Asynchrone Messung:</strong> Da die Befehle nacheinander abgearbeitet werden, ist es nicht möglich, mehrere Signale exakt gleichzeitig zu messen. Jedes Signal wird mit einer gewissen Zeitverzögerung nacheinander erfasst.</p>
</li>
<li>
<p><strong>Hohe Buslast bei vielen Signalen:</strong> Für jedes gemessene Signal werden mindestens zwei XCP-Nachrichten pro Zyklus benötigt (ein Befehl und eine Bestätigung). Bei einer großen Anzahl von Signalen kann dies zu einer erheblichen Belastung des Kommunikationsbusses führen, was die Gesamtleistung und Reaktionsfähigkeit des Systems beeinträchtigen kann.</p>
</li>
</ul>
<h3 id="vor--und-nachteile-des-polling-modus"><a class="header" href="#vor--und-nachteile-des-polling-modus">Vor- und Nachteile des Polling-Modus</a></h3>
<p><strong>Vorteile:</strong></p>
<ul>
<li><strong>Einfachheit:</strong> Der Polling-Modus ist einfach zu implementieren und eignet sich gut für Systeme mit wenigen Signalen und niedrigen Messraten.</li>
<li><strong>Geringer Ressourcenverbrauch:</strong> Bei einer begrenzten Anzahl von Signalen ist die Belastung des Kommunikationsbusses überschaubar.</li>
</ul>
<p><strong>Nachteile:</strong></p>
<ul>
<li><strong>Eingeschränkte Messgenauigkeit:</strong> Aufgrund der sequenziellen Verarbeitung können keine Signale exakt synchron erfasst werden, was die Genauigkeit in dynamischen Messanwendungen beeinträchtigen kann.</li>
<li><strong>Hohe Buslast bei vielen Signalen:</strong> Die Notwendigkeit, für jedes Signal separate Nachrichten zu senden, kann die Buskapazität schnell erschöpfen und die Systemleistung negativ beeinflussen.</li>
<li><strong>Begrenzte Skalierbarkeit:</strong> Der Polling-Modus ist weniger geeignet für komplexe Systeme mit einer großen Anzahl von Signalen oder hohen Messanforderungen.</li>
</ul>
<h3 id="anwendungsfälle-für-den-polling-modus"><a class="header" href="#anwendungsfälle-für-den-polling-modus">Anwendungsfälle für den Polling-Modus</a></h3>
<p>Der Polling-Modus eignet sich insbesondere für die Messung weniger dynamischer Signale bei niedrigeren Messraten. Beispiele hierfür sind:</p>
<ul>
<li><strong>Temperaturvariablen:</strong> Langsam wechselnde Größen wie Kühlmitteltemperaturen oder Motortemperaturen.</li>
<li><strong>Statusanzeigen:</strong> Zustände von Schaltern, Relais oder anderen binären Signalen, die selten wechseln.</li>
<li><strong>Langsame Prozessvariablen:</strong> Parameter wie Ölstand oder Luftdruck, die sich nur langsam ändern.</li>
</ul>
<p>Sollten Sie weitere Anwendungsfälle oder spezifische Szenarien im Auge haben, in denen der Polling-Modus von Nutzen sein könnte, empfiehlt es sich, diese Fragen direkt an den Trainer Ihres bevorstehenden CANape-Trainings zu richten. Dort können praxisnahe Beispiele und tiefgehende Erklärungen angeboten werden.</p>
<h2 id="vergleich-mit-dem-daq-modus"><a class="header" href="#vergleich-mit-dem-daq-modus">Vergleich mit dem DAQ-Modus</a></h2>
<p>Um Signale synchronisiert zu messen, also genau zur gleichen Zeit, muss der <strong>DAQ-Modus</strong> verwendet werden. Dieser Modus bietet eine effizientere Methode zur Erfassung mehrerer Signale gleichzeitig und minimiert die Buslast durch gebündelte Datenübertragung. Im nächsten Kapitel werden wir den DAQ-Modus detailliert untersuchen, seine Implementierung und Vorteile im Vergleich zum Polling-Modus erläutern und aufzeigen, wann der Einsatz des DAQ-Modus vorzuziehen ist.</p>
<h2 id="best-practices-für-den-einsatz-des-polling-modus"><a class="header" href="#best-practices-für-den-einsatz-des-polling-modus">Best Practices für den Einsatz des Polling-Modus</a></h2>
<p>Um den Polling-Modus effizient zu nutzen und dessen Einschränkungen zu minimieren, sollten folgende Best Practices beachtet werden:</p>
<ol>
<li><strong>Minimierung der Anzahl der Signale:</strong> Beschränken Sie die Anzahl der im Polling-Modus zu messenden Signale auf das notwendige Minimum, um die Buslast zu reduzieren.</li>
<li><strong>Optimierung der Messfrequenz:</strong> Passen Sie die Messrate an die Dynamik der zu messenden Signale an. Für langsam wechselnde Signale sind niedrigere Messfrequenzen ausreichend.</li>
<li><strong>Priorisierung wichtiger Signale:</strong> Priorisieren Sie kritische Signale, um sicherzustellen, dass diese trotz hoher Buslast zuverlässig erfasst werden.</li>
<li><strong>Effiziente Speicherverwaltung:</strong> Stellen Sie sicher, dass die Signale effizient im Speicher des Steuergeräts organisiert sind, um die Lesezeiten zu minimieren.</li>
<li><strong>Monitoring der Buslast:</strong> Überwachen Sie die Busauslastung kontinuierlich, um Engpässe frühzeitig zu erkennen und gegebenenfalls Anpassungen vorzunehmen.</li>
</ol>
<p>Durch die Einhaltung dieser Best Practices kann der Polling-Modus effektiv eingesetzt werden, insbesondere in Szenarien, in denen die Anforderungen an die Synchronisation und die Anzahl der zu messenden Signale moderat sind.</p>
<h2 id="fazit"><a class="header" href="#fazit">Fazit</a></h2>
<p>Der Polling-Modus stellt eine grundlegende Methode zur Signalerfassung in XCP dar, die sich durch ihre Einfachheit und geringe Ressourcennutzung auszeichnet. Dennoch ist er aufgrund seiner sequenziellen Natur und der daraus resultierenden Buslast bei der Messung vieler Signale nur für spezifische Anwendungsfälle geeignet. Für umfassendere und dynamischere Messanforderungen bietet der DAQ-Modus eine leistungsfähigere Alternative, die im nächsten Kapitel detailliert behandelt wird.</p>
<p>Der Polling-Modus in XCP bietet eine einfache und direkte Methode zur Signalerfassung, ist jedoch durch seine sequenzielle Natur und die daraus resultierende Buslast begrenzt. Für Anwendungen mit wenigen, wenig dynamischen Signalen und niedrigen Messraten ist er ideal geeignet. Bei komplexeren Anforderungen, die eine hohe Synchronisation und eine große Anzahl an Signalen erfordern, stellt der DAQ-Modus eine überlegene Alternative dar. Die Wahl des richtigen Messmodus hängt somit maßgeblich von den spezifischen Projektanforderungen ab.</p>
<h2 id="beispielkonfiguration-für-den-polling-modus-in-canape"><a class="header" href="#beispielkonfiguration-für-den-polling-modus-in-canape">Beispielkonfiguration für den Polling-Modus in CANape</a></h2>
<p>Um den Polling-Modus in CANape einzurichten, folgen Sie diesen Schritten:</p>
<ol>
<li>
<p><strong>Messkonfiguration öffnen:</strong></p>
<ul>
<li>Starten Sie CANape und öffnen Sie Ihr Projekt.</li>
<li>Navigieren Sie zur Messkonfiguration über das Menü <strong>"Measurement"</strong> &gt; <strong>"Configuration"</strong>.</li>
</ul>
</li>
<li>
<p><strong>Messmodus auswählen:</strong></p>
<ul>
<li>Im Bereich <strong>"XCP Settings"</strong> wählen Sie den <strong>"Polling-Modus"</strong> aus der Dropdown-Liste der verfügbaren Messmodi.</li>
</ul>
</li>
<li>
<p><strong>Signale hinzufügen:</strong></p>
<ul>
<li>Fügen Sie die gewünschten Signale zur Messkonfiguration hinzu, die im Polling-Modus erfasst werden sollen.</li>
<li>Stellen Sie sicher, dass die Signale korrekt adressiert und ihre Adressen im Steuergerät bekannt sind.</li>
</ul>
</li>
<li>
<p><strong>Befehle konfigurieren:</strong></p>
<ul>
<li>Konfigurieren Sie die XCP-Befehle <code>SHORT_UPLOAD</code> oder <code>UPLOAD</code> für jedes Signal.</li>
<li>Legen Sie die Abfragefrequenz fest, die der Dynamik der jeweiligen Signale entspricht.</li>
</ul>
</li>
<li>
<p><strong>Messlauf starten:</strong></p>
<ul>
<li>Starten Sie die Messung und überwachen Sie die erfassten Daten in Echtzeit.</li>
<li>Überprüfen Sie die Buslast und passen Sie bei Bedarf die Konfiguration an, um eine optimale Performance zu gewährleisten.</li>
</ul>
</li>
</ol>
<h2 id="tipps-zur-fehlerbehebung"><a class="header" href="#tipps-zur-fehlerbehebung">Tipps zur Fehlerbehebung</a></h2>
<ul>
<li>
<p><strong>Verzögerungen bei der Datenübertragung:</strong></p>
<ul>
<li>Überprüfen Sie die Netzwerkkonfiguration und stellen Sie sicher, dass die physikalischen Verbindungen stabil sind.</li>
<li>Reduzieren Sie die Anzahl der gleichzeitig abgefragten Signale, um die Buslast zu verringern.</li>
</ul>
</li>
<li>
<p><strong>Fehlende Bestätigungen:</strong></p>
<ul>
<li>Stellen Sie sicher, dass die Adressen und Speicherorte der Signale korrekt konfiguriert sind.</li>
<li>Überprüfen Sie die Firmware-Version des Steuergeräts und die Kompatibilität mit der verwendeten XCP-Implementierung.</li>
</ul>
</li>
<li>
<p><strong>Unstabile Messwerte:</strong></p>
<ul>
<li>Kalibrieren Sie die Messumgebung und prüfen Sie, ob elektromagnetische Störungen die Kommunikation beeinträchtigen.</li>
<li>Nutzen Sie Filteroptionen in CANape, um Rauschen und unerwünschte Signalabweichungen zu minimieren.</li>
</ul>
</li>
</ul>
<p>Durch systematisches Vorgehen und gezielte Anpassungen können die meisten Probleme im Polling-Modus schnell identifiziert und behoben werden.</p>
<h2 id="fragen"><a class="header" href="#fragen">Fragen</a></h2>
<ol>
<li>
<p><strong>Was sind die Hauptunterschiede zwischen dem Polling-Modus und dem DAQ-Modus in XCP?</strong></p>
<ul>
<li>Der Polling-Modus arbeitet sequenziell, indem jedes Signal einzeln abgefragt wird, während der DAQ-Modus mehrere Signale gleichzeitig erfasst. Der Polling-Modus erfordert für jedes Signal eine separate Nachricht, was die Buslast erhöht, während der DAQ-Modus effizienter ist und die Buslast durch gebündelte Übertragung reduziert.</li>
</ul>
</li>
<li>
<p><strong>Wie wird der Polling-Modus in XCP implementiert, und welche Befehle werden dabei verwendet?</strong></p>
<ul>
<li>Der Polling-Modus wird durch die Befehle <code>SHORT_UPLOAD</code> oder <code>UPLOAD</code> implementiert. Der Master sendet einen dieser Befehle, um ein Signal vom Steuergerät zu lesen. Nach der Verarbeitung und Bestätigung des Befehls kann der Master den nächsten Befehl senden.</li>
</ul>
</li>
<li>
<p><strong>Welche Auswirkungen hat die sequenzielle Verarbeitung der Befehle im Polling-Modus auf die Buslast?</strong></p>
<ul>
<li>Die sequenzielle Verarbeitung führt dazu, dass für jedes Signal mindestens zwei Nachrichten (Befehl und Bestätigung) gesendet werden. Dies kann die Buslast erheblich erhöhen, insbesondere wenn viele Signale erfasst werden, und die Leistung des Systems beeinträchtigen.</li>
</ul>
</li>
<li>
<p><strong>Welche Vorteile bietet der Polling-Modus?</strong></p>
<ul>
<li>Der Polling-Modus ist einfach zu implementieren und verbraucht bei wenigen Signalen und niedrigen Messraten nur geringe Ressourcen. Er eignet sich besonders gut für Systeme, in denen die Messgenauigkeit und Synchronität keine entscheidenden Faktoren sind.</li>
</ul>
</li>
<li>
<p><strong>Welche Nachteile hat der Polling-Modus im Vergleich zum DAQ-Modus?</strong></p>
<ul>
<li>Der Polling-Modus erfasst Signale nicht synchron, was die Messgenauigkeit bei dynamischen Signalen beeinträchtigt. Außerdem erzeugt er eine hohe Buslast bei vielen Signalen und skaliert schlecht bei größeren oder komplexeren Systemen.</li>
</ul>
</li>
<li>
<p><strong>Für welche Anwendungsfälle ist der Polling-Modus besonders geeignet?</strong></p>
<ul>
<li>Der Polling-Modus ist besonders geeignet für langsam wechselnde Signale wie Temperaturmessungen, Statusanzeigen oder Prozessvariablen, die sich nicht schnell ändern. Er wird häufig verwendet, wenn keine hohe Synchronität zwischen den Signalen erforderlich ist.</li>
</ul>
</li>
<li>
<p><strong>Welche Best Practices sollten bei der Verwendung des Polling-Modus beachtet werden?</strong></p>
<ul>
<li>Um den Polling-Modus effizient zu nutzen, sollten die Anzahl der gemessenen Signale minimiert, die Messfrequenz den Signaldynamiken angepasst und wichtige Signale priorisiert werden. Eine effiziente Speicherverwaltung im Steuergerät und die kontinuierliche Überwachung der Buslast sind ebenfalls entscheidend.</li>
</ul>
</li>
<li>
<p><strong>Wie wird der Polling-Modus in CANape konfiguriert?</strong></p>
<ul>
<li>In CANape wird der Polling-Modus in den <strong>XCP Settings</strong> ausgewählt. Anschließend werden die zu messenden Signale hinzugefügt, die <code>SHORT_UPLOAD</code>- oder <code>UPLOAD</code>-Befehle konfiguriert und die Abfragefrequenz angepasst. Nach dem Start der Messung wird die Buslast überwacht und die Konfiguration bei Bedarf optimiert.</li>
</ul>
</li>
<li>
<p><strong>Welche Kommunikationsprobleme können im Polling-Modus auftreten und wie werden diese behoben?</strong></p>
<ul>
<li>Häufige Probleme umfassen Verzögerungen bei der Datenübertragung, fehlende Bestätigungen und unstabile Messwerte. Diese können durch Überprüfung der Netzwerkkonfiguration, Reduzierung der Buslast, Anpassung der Adressen und Speicherorte sowie die Kalibrierung der Messumgebung behoben werden.</li>
</ul>
</li>
<li>
<p><strong>Wie kann die Messgenauigkeit im Polling-Modus optimiert werden, obwohl die Signale nicht synchron erfasst werden?</strong></p>
<ul>
<li>Die Messgenauigkeit kann durch die Anpassung der Abfragefrequenzen und die Priorisierung wichtiger Signale optimiert werden. Außerdem hilft die Minimierung der Anzahl abgefragter Signale, die Gesamtperformance und Zuverlässigkeit der Messungen zu verbessern.</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../00_Einstieg/01_Introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../00_Einstieg/03_Synchronous_Data_Aquisition.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../00_Einstieg/01_Introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../00_Einstieg/03_Synchronous_Data_Aquisition.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
