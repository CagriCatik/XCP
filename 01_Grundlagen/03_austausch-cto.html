<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Austausch CTO</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../00_Einstieg/index.html"><strong aria-hidden="true">1.</strong> Einstieg</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../00_Einstieg/01_Introduction.html"><strong aria-hidden="true">1.1.</strong> Einführung</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/02_Polling.html"><strong aria-hidden="true">1.2.</strong> Polling</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/03_Synchronous_Data_Aquisition.html"><strong aria-hidden="true">1.3.</strong> Synchronous Data Aquisition</a></li><li class="chapter-item expanded "><a href="../00_Einstieg/04_Performance_Analysis.html"><strong aria-hidden="true">1.4.</strong> Performance Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../01_Grundlagen/index.html"><strong aria-hidden="true">2.</strong> Grundlagen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_Grundlagen/01_xcp-kommunikationsprotokoll.html"><strong aria-hidden="true">2.1.</strong> XCP Kommunikationsprotokoll</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/02_xcp-protokollschicht.html"><strong aria-hidden="true">2.2.</strong> XCP Protokollschicht</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/03_austausch-cto.html" class="active"><strong aria-hidden="true">2.3.</strong> Austausch CTO</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/04_austausch_dto.html"><strong aria-hidden="true">2.4.</strong> Austausch DTO</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/05_zeit-korrelation.html"><strong aria-hidden="true">2.5.</strong> Zeit Korrelation</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/06_xcp-transportschichten.html"><strong aria-hidden="true">2.6.</strong> XCP Transportschichten</a></li><li class="chapter-item expanded "><a href="../01_Grundlagen/07_xcp-services.html"><strong aria-hidden="true">2.7.</strong> XCP Services</a></li></ol></li><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/index.html"><strong aria-hidden="true">3.</strong> Beschreibung von A2L</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/01_aufbau-a2l.html"><strong aria-hidden="true">3.1.</strong> Aufbau der A2L</a></li><li class="chapter-item expanded "><a href="../02_Beschreibung_A2L/02_manuelle-a2l-erstellung.html"><strong aria-hidden="true">3.2.</strong> Manuelle A2L Erstellung</a></li></ol></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/index.html"><strong aria-hidden="true">4.</strong> Kalibrierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/01_parameter-flash.html"><strong aria-hidden="true">4.1.</strong> Parameter Flash</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/02_parameter-ram.html"><strong aria-hidden="true">4.2.</strong> Parameter RAM</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/03_flash-overlay.html"><strong aria-hidden="true">4.3.</strong> Flash Overlay</a></li><li class="chapter-item expanded "><a href="../03_Kalibrierkonzepte/04_dynamic-flash-overlay.html"><strong aria-hidden="true">4.4.</strong> Dynamic Flash Overlay</a></li></ol></li><li class="chapter-item expanded "><a href="../04_Tooling/index.html"><strong aria-hidden="true">5.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04_Tooling/01_Messen_Auswerten.html"><strong aria-hidden="true">5.1.</strong> Messen & Auswerten</a></li><li class="chapter-item expanded "><a href="../04_Tooling/02_Kalibrieren_Verwalten.html"><strong aria-hidden="true">5.2.</strong> Kalibrieren & Verwalten</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="austausch-von-ctos-im-asam-xcp-protokoll"><a class="header" href="#austausch-von-ctos-im-asam-xcp-protokoll">Austausch von CTOs im ASAM XCP-Protokoll</a></h1>
<p>Der Austausch von CTOs (Command and Response Transport Objects) bildet das Rückgrat der Kommunikation zwischen Master und Slave im ASAM XCP (Universal Measurement and Calibration Protocol). Dieses Protokoll ermöglicht eine effiziente und flexible Datenübertragung für Mess- und Kalibrieranwendungen in der Automobilindustrie und anderen Bereichen. Im Folgenden wird die Struktur und Funktionsweise des CTO-Austauschs detailliert erläutert.</p>
<h2 id="grundlegende-kommunikationsstruktur"><a class="header" href="#grundlegende-kommunikationsstruktur">Grundlegende Kommunikationsstruktur</a></h2>
<p>In der XCP-Kommunikation fungiert der Master als Initiator der Kommunikation, während der Slave als Empfänger agiert. Die Interaktion erfolgt über den Austausch von Kommandos (CMD) und entsprechenden Antworten (RES oder ERR). Jedes Kommando, das der Master an den Slave sendet, muss vom Slave mit einer positiven (RES) oder negativen (ERR) Antwort quittiert werden. Diese strukturierte Kommunikation gewährleistet eine zuverlässige und nachvollziehbare Datenübertragung.</p>
<h2 id="aufbau-eines-cto-pakets"><a class="header" href="#aufbau-eines-cto-pakets">Aufbau eines CTO-Pakets</a></h2>
<p>Ein CTO-Paket besteht aus mehreren Komponenten, die eine eindeutige Identifikation und Verarbeitung des Kommandos ermöglichen:</p>
<ul>
<li><strong>Packet Identifier (PID):</strong> Dieses Feld, das den Wertbereich von <code>0xC0</code> bis <code>0xFF</code> umfasst, dient der eindeutigen Identifikation des Kommandos.</li>
<li><strong>Command Data:</strong> Hier werden spezifische Parameter des Kommandos übertragen. Die Anzahl der Parameter ist durch <code>MAX_CTO-1</code> begrenzt, wobei <code>MAX_CTO</code> die maximale Länge des CTO-Pakets in Bytes definiert.</li>
</ul>
<p>Die allgemeine Struktur eines CTO-Pakets ist wie folgt:</p>
<div class="table-wrapper"><table><thead><tr><th>Position</th><th>Byte-Bereich</th><th>Beschreibung</th></tr></thead><tbody>
<tr><td>0</td><td>1 Byte</td><td>Packet Identifier CMD (0xC0…0xFF)</td></tr>
<tr><td>1..MAX_CTO-1</td><td>MAX_CTO-1 Bytes</td><td>Command Data</td></tr>
</tbody></table>
</div>
<h2 id="positive-und-negative-antworten"><a class="header" href="#positive-und-negative-antworten">Positive und Negative Antworten</a></h2>
<p>Sowohl positive als auch negative Antworten können zusätzliche spezifische Parameter enthalten, die weiterführende Informationen über den Status oder Fehler liefern. Beispielsweise erfolgt beim Verbindungsaufbau zwischen Master und Slave ein Austausch von Connect-Kommando und positiver Antwort:</p>
<ol>
<li><strong>Master → Slave:</strong> <code>Connect</code></li>
<li><strong>Slave → Master:</strong> <code>Positive Response</code></li>
</ol>
<p>Im Falle einer positiven Antwort kann der Slave dem Master kommunikationsspezifische Informationen übermitteln, wie etwa die Unterstützung von Page Switching (<code>RESOURCE</code>) oder die maximale Paketlänge für die Messdatenübertragung (<code>MAX_DTO</code>). Diese Informationen sind in der ASAM XCP Teil 2 Protocol Layer Spezifikation detailliert beschrieben.</p>
<h2 id="kommando--und-antwortmechanismus"><a class="header" href="#kommando--und-antwortmechanismus">Kommando- und Antwortmechanismus</a></h2>
<p>Der Master sendet ein Kommando an den Slave, wobei das <code>PID</code>-Feld die spezifische Identifikationsnummer des Kommandos enthält. Im Datenfeld des Pakets werden zusätzliche Parameter übertragen. Nach dem Senden des Kommandos wartet der Master auf die Reaktion des Slaves, die entweder eine positive Antwort (<code>RES</code>) oder ein Fehlerkommando (<code>ERR</code>) sein kann.</p>
<p>Ein wichtiger Aspekt der XCP-Implementierung ist ihre Skalierbarkeit. Nicht jedes Kommando muss zwingend implementiert werden. Die verfügbaren Kommandos sind in der A2L-Datei unter dem Abschnitt <code>XCP IF_DATA</code> aufgelistet. Sollte ein Kommando, das der Master sendet, vom Slave nicht unterstützt werden, antwortet der Slave mit <code>ERR_CMD_UNKNOWN</code>, wodurch der Master erkennt, dass das Kommando nicht implementiert ist und keine weiteren Aktivitäten im Slave ausgelöst werden.</p>
<h2 id="gruppierung-der-kommandos"><a class="header" href="#gruppierung-der-kommandos">Gruppierung der Kommandos</a></h2>
<p>Die XCP-Kommandos sind in verschiedene Gruppen unterteilt, die unterschiedliche Funktionalitäten abdecken. Diese Gruppierung ermöglicht eine modulare Implementierung, bei der nur die benötigten Kommandos realisiert werden müssen. Die Hauptgruppen sind:</p>
<ul>
<li><strong>Standardkommandos</strong></li>
<li><strong>Kalibrierkommandos</strong></li>
<li><strong>Seitenumschaltungs-Kommandos</strong></li>
<li><strong>Programmierkommandos</strong></li>
<li><strong>Debugging-Kommandos</strong></li>
<li><strong>DAQ-Kommandos (Data Acquisition)</strong></li>
</ul>
<p>Innerhalb jeder Gruppe können bestimmte Kommandos als obligatorisch oder optional gekennzeichnet sein. Beispielsweise müssen in der Gruppe der Seitenumschaltungs-Kommandos <code>SET_CAL_PAGE</code> und <code>GET_CAL_PAGE</code> implementiert sein, wenn der Slave Page Switching unterstützt. Andernfalls können diese Kommandos weggelassen werden.</p>
<h2 id="Übersicht-der-standardkommandos"><a class="header" href="#Übersicht-der-standardkommandos">Übersicht der Standardkommandos</a></h2>
<p>Die Standardkommandos bilden das Fundament der XCP-Kommunikation und umfassen grundlegende Funktionen wie Verbindungsmanagement, Statusabfragen und Identifikationsprozesse. Eine Auswahl dieser Kommandos ist im Folgenden dargestellt:</p>
<div class="table-wrapper"><table><thead><tr><th>Kommando</th><th>PID</th><th>Optionalität</th></tr></thead><tbody>
<tr><td>CONNECT</td><td>0xFF</td><td>Nein</td></tr>
<tr><td>DISCONNECT</td><td>0xFE</td><td>Nein</td></tr>
<tr><td>GET_STATUS</td><td>0xFD</td><td>Nein</td></tr>
<tr><td>SYNCH</td><td>0xFC</td><td>Nein</td></tr>
<tr><td>GET_COMM_MODE_INFO</td><td>0xFB</td><td>Ja</td></tr>
<tr><td>GET_ID</td><td>0xFA</td><td>Ja</td></tr>
<tr><td>SET_REQUEST</td><td>0xF9</td><td>Ja</td></tr>
<tr><td>GET_SEED</td><td>0xF8</td><td>Ja</td></tr>
<tr><td>UNLOCK</td><td>0xF7</td><td>Ja</td></tr>
<tr><td>SET_MTA</td><td>0xF6</td><td>Ja</td></tr>
<tr><td>UPLOAD</td><td>0xF5</td><td>Ja</td></tr>
<tr><td>SHORT_UPLOAD</td><td>0xF4</td><td>Ja</td></tr>
<tr><td>BUILD_CHECKSUM</td><td>0xF3</td><td>Ja</td></tr>
<tr><td>TRANSPORT_LAYER_CMD</td><td>0xF2</td><td>Ja</td></tr>
<tr><td>USER_CMD</td><td>0xF1</td><td>Ja</td></tr>
<tr><td>GET_VERSIONPID</td><td>0xC0, 0x00</td><td>Optional</td></tr>
</tbody></table>
</div>
<p>Diese Kommandos decken eine Vielzahl von Funktionen ab, von der Herstellung und Beendigung der Verbindung (<code>CONNECT</code>, <code>DISCONNECT</code>) über Statusabfragen (<code>GET_STATUS</code>) bis hin zu spezifischen Steuerbefehlen (<code>SET_REQUEST</code>, <code>UNLOCK</code>).</p>
<h2 id="kalibrierkommandos"><a class="header" href="#kalibrierkommandos">Kalibrierkommandos</a></h2>
<p>Kalibrierkommandos sind essenziell für die Anpassung und Optimierung der Messsysteme. Sie ermöglichen das Herunterladen und Modifizieren von Kalibrierdaten sowie die Verwaltung von Bits und Speicherbereichen. Wichtige Kalibrierkommandos umfassen:</p>
<div class="table-wrapper"><table><thead><tr><th>Kommando</th><th>PID</th><th>Optionalität</th></tr></thead><tbody>
<tr><td>DOWNLOAD</td><td>0xF0</td><td>Nein</td></tr>
<tr><td>DOWNLOAD_NEXT</td><td>0xEF</td><td>Ja</td></tr>
<tr><td>DOWNLOAD_MAX</td><td>0xEE</td><td>Ja</td></tr>
<tr><td>SHORT_DOWNLOAD</td><td>0xED</td><td>Ja</td></tr>
<tr><td>MODIFY_BITSPID</td><td>0xEC</td><td>Ja</td></tr>
</tbody></table>
</div>
<p>Diese Kommandos ermöglichen eine präzise Steuerung der Kalibrierprozesse und sind daher unverzichtbar für eine genaue Messdatenerfassung und -analyse.</p>
<h2 id="seitenumschaltung"><a class="header" href="#seitenumschaltung">Seitenumschaltung</a></h2>
<p>Die Seitenumschaltungs-Kommandos ermöglichen das Wechseln zwischen verschiedenen Kalibrierungsseiten oder Speicherbereichen im Slave. Dies ist besonders nützlich, wenn verschiedene Messbereiche oder Konfigurationen benötigt werden. Wichtige Kommandos in dieser Gruppe sind:</p>
<div class="table-wrapper"><table><thead><tr><th>Kommando</th><th>PID</th><th>Optionalität</th></tr></thead><tbody>
<tr><td>SET_CAL_PAGE</td><td>0xEB</td><td>Nein</td></tr>
<tr><td>GET_CAL_PAGE</td><td>0xEA</td><td>Nein</td></tr>
<tr><td>GET_PAG_PROCESSOR_INFO</td><td>0xE9</td><td>Ja</td></tr>
<tr><td>GET_SEGMENT_INFO</td><td>0xE8</td><td>Ja</td></tr>
<tr><td>GET_PAGE_INFO</td><td>0xE7</td><td>Ja</td></tr>
<tr><td>SET_SEGMENT_MODE</td><td>0xE6</td><td>Ja</td></tr>
<tr><td>GET_SEGMENT_MODE</td><td>0xE5</td><td>Ja</td></tr>
<tr><td>COPY_CAL_PAGE</td><td>0xE4</td><td>Ja</td></tr>
</tbody></table>
</div>
<p>Diese Kommandos ermöglichen eine flexible Verwaltung der Kalibrierungsdaten und unterstützen komplexe Konfigurationsanforderungen.</p>
<h2 id="zyklischer-datenaustausch-daq"><a class="header" href="#zyklischer-datenaustausch-daq">Zyklischer Datenaustausch (DAQ)</a></h2>
<p>Der zyklische Datenaustausch ist ein zentrales Element für die kontinuierliche Erfassung von Messdaten. Die DAQ-Kommandos ermöglichen das Einrichten, Starten, Stoppen und Konfigurieren von DAQ-Listen, die die zu erfassenden Datenpunkte definieren. Die DAQ-Kommandos sind in drei Kategorien unterteilt:</p>
<ol>
<li>
<p><strong>Basics:</strong></p>
<ul>
<li><code>SET_DAQ_PTR</code> (0xE2)</li>
<li><code>WRITE_DAQ</code> (0xE1)</li>
<li><code>SET_DAQ_LIST_MODE</code> (0xE0)</li>
<li><code>START_STOP_DAQ_LIST</code> (0xDE)</li>
<li><code>START_STOP_SYNCH</code> (0xDD)</li>
<li><code>WRITE_DAQ_MULTIPLE</code> (0xC7)</li>
<li><code>READ_DAQ</code> (0xDB)</li>
<li><code>GET_DAQ_CLOCK</code> (0xDC)</li>
<li><code>GET_DAQ_PROCESSOR_INFO</code> (0xDA)</li>
<li><code>GET_DAQ_RESOLUTION_INFO</code> (0xD9)</li>
<li><code>GET_DAQ_LIST_MODE</code> (0xDF)</li>
<li><code>GET_DAQ_EVENT_INFO</code> (0xD7)</li>
<li><code>DTO_CTR_Properties</code> (0xC5)</li>
<li><code>SET_DAQ_PACKED_MODE</code> (0xC0, 0x01)</li>
<li><code>Get_DAQ_PACKED_Mode</code> (0xC0, 0x02)</li>
</ul>
</li>
<li>
<p><strong>Statische Konfiguration:</strong></p>
<ul>
<li><code>CLEAR_DAQ_LIST</code> (0xE3)</li>
<li><code>GET_DAQ_LIST_INFO</code> (0xD8)</li>
</ul>
</li>
<li>
<p><strong>Dynamische Konfiguration:</strong></p>
<ul>
<li><code>FREE_DAQ</code> (0xD6)</li>
<li><code>ALLOC_DAQ</code> (0xD5)</li>
<li><code>ALLOC_ODT</code> (0xD4)</li>
<li><code>ALLOC_ODT_ENTRY</code> (0xD3)</li>
</ul>
</li>
</ol>
<p>Diese Kommandos ermöglichen eine umfassende Steuerung des DAQ-Prozesses, von der Initialisierung über die Konfiguration bis hin zur Datenerfassung und -verwaltung.</p>
<h2 id="flash-programmierung"><a class="header" href="#flash-programmierung">Flash-Programmierung</a></h2>
<p>Die Flash-Programmierungs-Kommandos sind essenziell für das Schreiben und Verwalten von Firmware im Slave. Sie umfassen Befehle zum Starten, Löschen, Überprüfen und Verifizieren der Programmierung. Wichtige Kommandos sind:</p>
<div class="table-wrapper"><table><thead><tr><th>Kommando</th><th>PID</th><th>Optionalität</th></tr></thead><tbody>
<tr><td>PROGRAM_START</td><td>0xD2</td><td>Nein</td></tr>
<tr><td>PROGRAM_CLEAR</td><td>0xD1</td><td>Nein</td></tr>
<tr><td>PROGRAM_RESET</td><td>0xD0</td><td>Nein</td></tr>
<tr><td>GET_PGM_PROCESSOR_INFO</td><td>0xCF</td><td>Ja</td></tr>
<tr><td>GET_SECTOR_INFO</td><td>0xCE</td><td>Ja</td></tr>
<tr><td>PROGRAM_PREPARE</td><td>0xCD</td><td>Ja</td></tr>
<tr><td>PROGRAM_FORMAT</td><td>0xCC</td><td>Ja</td></tr>
<tr><td>PROGRAM_NEXT</td><td>0xCB</td><td>Ja</td></tr>
<tr><td>PROGRAM_MAX</td><td>0xCA</td><td>Ja</td></tr>
<tr><td>PROGRAM_VERIFY</td><td>0xC9</td><td>Ja</td></tr>
</tbody></table>
</div>
<p>Diese Kommandos gewährleisten eine sichere und effiziente Programmierung der Firmware, was für die Aktualisierung und Wartung von Steuergeräten unerlässlich ist.</p>
<h2 id="zeitsynchronisierung"><a class="header" href="#zeitsynchronisierung">Zeitsynchronisierung</a></h2>
<p>Das Kommando <code>TIME_CORRELATION_PROPERTIES</code> (0xC6) ermöglicht die Synchronisierung der Zeit zwischen Master und Slave. Dies ist besonders wichtig für zeitkritische Anwendungen, bei denen die genaue Zuordnung von Messdaten zu Zeitpunkten erforderlich ist.</p>
<h2 id="unterstützung-von-asam-standards"><a class="header" href="#unterstützung-von-asam-standards">Unterstützung von ASAM-Standards</a></h2>
<p>XCP unterstützt verschiedene ASAM-Standards, die zusätzliche Funktionalitäten und Kommandos bereitstellen. Beispiele hierfür sind:</p>
<ul>
<li><strong>ASAM AE MCD-1-XCP AS SW-DBG-over-XCP:</strong> PID <code>0xC0, 0xFC</code></li>
<li><strong>DBG-over-XCP ASAM AE MCD-1 POD BS:</strong> PID <code>0xC0, 0xFD</code></li>
</ul>
<p>Diese erweiterten Kommandos ermöglichen eine tiefere Integration und spezifische Anpassungen an besondere Anforderungen von Anwendungen und Systemen.</p>
<h2 id="fazit"><a class="header" href="#fazit">Fazit</a></h2>
<p>Der Austausch von CTOs im ASAM XCP-Protokoll ist ein komplexes, aber hochflexibles System, das eine präzise und zuverlässige Kommunikation zwischen Master und Slave gewährleistet. Durch die modulare Struktur der Kommandos und die Möglichkeit zur Erweiterung und Anpassung an spezifische Anforderungen bietet XCP eine leistungsfähige Lösung für Mess- und Kalibrieranwendungen in der modernen Automobilindustrie und darüber hinaus. Ein tiefes Verständnis der Kommandostruktur und der Kommunikationsmechanismen ist unerlässlich, um das volle Potenzial des XCP-Protokolls auszuschöpfen und eine effiziente Implementierung zu gewährleisten.</p>
<h3 id="erweiterte-analyse-der-xcp-kommunikationsmechanismen-res-err-ev-serv-und-parameterverwaltung"><a class="header" href="#erweiterte-analyse-der-xcp-kommunikationsmechanismen-res-err-ev-serv-und-parameterverwaltung">Erweiterte Analyse der XCP-Kommunikationsmechanismen: RES, ERR, EV, SERV und Parameterverwaltung</a></h3>
<p>Im Rahmen des ASAM XCP (Universal Measurement and Calibration Protocol) ist die effiziente und zuverlässige Kommunikation zwischen Master und Slave von zentraler Bedeutung. Neben dem Austausch von CTOs (Command and Response Transport Objects) spielen die Mechanismen RES (Response), ERR (Error), EV (Event) und SERV (Service Request) eine entscheidende Rolle für die Steuerung und Überwachung des Systems. Zudem ist die Verwaltung von Parametern im Slave ein kritischer Aspekt für die Anpassung und Optimierung von Steuergeräten. Dieser Text bietet eine detaillierte Analyse dieser Komponenten aus der Perspektive eines XCP-Experten.</p>
<hr />
<h4 id="1-res-positive-antworten-des-slaves"><a class="header" href="#1-res-positive-antworten-des-slaves">1. RES: Positive Antworten des Slaves</a></h4>
<p><strong>Definition und Funktion:</strong></p>
<p>RES steht für "Response" und signalisiert dem Master, dass eine Anforderung erfolgreich umgesetzt wurde. Wenn der Slave ein Kommando vom Master erhält und dieses korrekt ausführen kann, sendet er eine positive Bestätigung zurück.</p>
<p><strong>Struktur und Inhalte:</strong></p>
<p>Die RES-Nachricht enthält nicht nur die Bestätigung der erfolgreichen Ausführung, sondern kann auch zusätzliche Parameter zur Verfügung stellen. Diese Parameter bieten weiterführende Informationen über den Status oder spezifische Ergebnisse der ausgeführten Aktion.</p>
<p><strong>Beispielhafte Anwendung:</strong></p>
<p>Beim Verbindungsaufbau sendet der Master ein <code>Connect</code>-Kommando. Der Slave bestätigt dies mit einer RES-Nachricht, die zusätzlich Informationen wie unterstützte Funktionen oder maximale Paketgrößen enthalten kann.</p>
<p><strong>Referenz:</strong></p>
<p>Für detaillierte Informationen über die enthaltenen Parameter verweist die ASAM XCP Protocol Layer Spezifikation auf spezifische Abschnitte, die die Struktur und Bedeutung dieser Parameter erläutern.</p>
<hr />
<h4 id="2-err-fehlerbehandlung-im-kommunikationsprozess"><a class="header" href="#2-err-fehlerbehandlung-im-kommunikationsprozess">2. ERR: Fehlerbehandlung im Kommunikationsprozess</a></h4>
<p><strong>Definition und Funktion:</strong></p>
<p>ERR steht für "Error" und wird vom Slave gesendet, wenn eine Anforderung des Masters nicht verarbeitet werden kann. Dies kann auf verschiedene Ursachen zurückzuführen sein, wie beispielsweise ungültige Befehle, Ressourcenmangel oder andere Implementierungsfehler.</p>
<p><strong>Struktur und Inhalte:</strong></p>
<p>Die ERR-Nachricht enthält einen spezifischen Fehlercode, der die Art des Fehlers beschreibt. Diese Fehlercodes sind in der ASAM XCP Protocol Layer Spezifikation detailliert aufgeführt und ermöglichen es dem Master, die genaue Ursache des Fehlers zu identifizieren und entsprechende Maßnahmen zu ergreifen.</p>
<p><strong>Beispielhafte Anwendung:</strong></p>
<p>Wenn der Master ein Kommando sendet, das der Slave nicht unterstützt, antwortet der Slave mit <code>ERR_CMD_UNKNOWN</code>. Dies signalisiert dem Master, dass das gesendete Kommando nicht implementiert ist, wodurch der Master weitere Aktivitäten im Slave vermeiden kann.</p>
<p><strong>Fehlercodes:</strong></p>
<p>Die ASAM XCP Spezifikation definiert eine Vielzahl von Fehlercodes, die unterschiedliche Fehlersituationen abdecken, beispielsweise:</p>
<ul>
<li><code>ERR_CMD_UNKNOWN</code> (0x10): Unbekanntes Kommando</li>
<li><code>ERR_CMD_SYNTAX</code> (0x11): Syntaxfehler im Kommando</li>
<li><code>ERR_RESOURCES</code> (0x12): Ressourcenmangel</li>
</ul>
<hr />
<h4 id="3-ev-asynchrone-ereignisbenachrichtigungen"><a class="header" href="#3-ev-asynchrone-ereignisbenachrichtigungen">3. EV: Asynchrone Ereignisbenachrichtigungen</a></h4>
<p><strong>Definition und Funktion:</strong></p>
<p>EV steht für "Event" und ermöglicht es dem Slave, den Master über asynchrone Ereignisse zu informieren. Diese Ereignisse können beispielsweise Störungen, Funktionsausfälle oder andere wichtige Systemänderungen sein.</p>
<p><strong>Struktur und Inhalte:</strong></p>
<p>Ein EV-Paket enthält Informationen über das aufgetretene Ereignis, einschließlich eines Ereigniscodes und optionaler zusätzlicher Parameter, die das Ereignis näher beschreiben.</p>
<p><strong>Optionale Implementierung:</strong></p>
<p>Die Implementierung von EV ist optional und hängt von den spezifischen Anforderungen der Anwendung ab. In Szenarien, in denen eine kontinuierliche Überwachung und schnelle Reaktion auf Systemereignisse erforderlich ist, kann die Nutzung von EV-Kommunikation von großem Vorteil sein.</p>
<p><strong>Beispielhafte Anwendung:</strong></p>
<p>Ein Slave erkennt einen Ausfall der Kommunikationsschnittstelle und sendet ein EV-Paket an den Master, um diesen über den Vorfall zu informieren. Der Master kann daraufhin entsprechende Maßnahmen ergreifen, wie das Initiieren eines Neustarts oder das Benachrichtigen eines Bedieners.</p>
<p><strong>Unterscheidung von Mess- und Stimulationsevents:</strong></p>
<p>Es ist wichtig zu beachten, dass EV-Nachrichten des Slaves sich von Ereignissen im Zusammenhang mit Messungen und Stimulation unterscheiden. Während letztere typischerweise von der Mess- oder Steuerlogik ausgelöst werden, dienen EV-Nachrichten der systemweiten Überwachung und Fehlermeldung.</p>
<hr />
<h4 id="4-serv-service-anfragen-des-slaves"><a class="header" href="#4-serv-service-anfragen-des-slaves">4. SERV: Service-Anfragen des Slaves</a></h4>
<p><strong>Definition und Funktion:</strong></p>
<p>SERV steht für "Service Request" und ermöglicht es dem Slave, den Master zur Ausführung bestimmter Service-Aufgaben aufzufordern. Dies ist besonders nützlich, wenn der Slave erkennt, dass bestimmte Aktionen auf der Master-Seite erforderlich sind, um den Betrieb fortzusetzen oder wiederherzustellen.</p>
<p><strong>Struktur und Inhalte:</strong></p>
<p>Ein SERV-Paket enthält einen Service-Request-Code, der die spezifische angeforderte Dienstleistung beschreibt. Diese Codes sind in der ASAM XCP Protocol Layer Spezifikation definiert und decken eine Vielzahl von möglichen Service-Anforderungen ab.</p>
<p><strong>Beispielhafte Anwendung:</strong></p>
<p>Der Slave erkennt, dass ein Neustart des Systems notwendig ist, um eine fehlerhafte Funktionalität zu beheben. Er sendet eine SERV-Nachricht mit dem entsprechenden Service-Request-Code, der den Master auffordert, einen Reset-Befehl auszuführen.</p>
<p><strong>Service-Request-Code-Tabelle:</strong></p>
<p>Die spezifischen Service-Request-Codes sind in der ASAM XCP Spezifikation aufgeführt und umfassen Anforderungen wie:</p>
<ul>
<li><code>SERV_RESET</code> (0x01): Anforderung eines Systemneustarts</li>
<li><code>SERV_CALIBRATE</code> (0x02): Anforderung einer Kalibrierungsroutine</li>
<li><code>SERV_UPDATE</code> (0x03): Anforderung eines Firmware-Updates</li>
</ul>
<hr />
<h4 id="5-parameterverwaltung-im-xcp-slave"><a class="header" href="#5-parameterverwaltung-im-xcp-slave">5. Parameterverwaltung im XCP-Slave</a></h4>
<p>Die Verwaltung von Parametern im Slave ist ein wesentlicher Bestandteil der XCP-Kommunikation, da sie die Anpassung und Optimierung von Steuergeräten ermöglicht. Dieser Prozess umfasst das Verstellen von Parametern sowie die dauerhafte Speicherung der geänderten Werte.</p>
<h5 id="51-verstellen-von-parametern"><a class="header" href="#51-verstellen-von-parametern">5.1 Verstellen von Parametern</a></h5>
<p><strong>Adressierung und Datenübertragung:</strong></p>
<p>Um einen Parameter im Slave zu ändern, muss der Master sowohl die Adresse des Parameters als auch den neuen Wert an den Slave senden. XCP definiert Adressen mit fünf Bytes: vier für die eigentliche Adresse und ein Byte für die Adress-Extension.</p>
<p><strong>Herausforderungen bei der Übertragung über CAN:</strong></p>
<p>Im Kontext einer CAN-Übertragung stehen nur sieben Nutzbytes pro Frame zur Verfügung. Bei der Änderung eines 4-Byte-Werts sind insgesamt neun Bytes (fünf für die Adresse und vier für den Wert) erforderlich. Dies überschreitet die Kapazität eines einzelnen CAN-Frames, sodass die Änderung über zwei Pakete übertragen werden muss.</p>
<p><strong>Kommunikationsablauf:</strong></p>
<ol>
<li>
<p><strong>Erstes Paket:</strong></p>
<ul>
<li><strong>Kommando:</strong> <code>SET_MTA</code> (Set Memory Transfer Address)</li>
<li><strong>Dateninhalt:</strong> Adresse des Parameters (z.B., HEX: <code>001C002C</code>, Extension: <code>0</code>)</li>
<li><strong>Bestätigung:</strong> Slave antwortet mit <code>RES: SET_MTA</code></li>
</ul>
</li>
<li>
<p><strong>Zweites Paket:</strong></p>
<ul>
<li><strong>Kommando:</strong> <code>DOWNLOAD</code></li>
<li><strong>Dateninhalt:</strong> Neuer Wert (z.B., HEX: <code>00 00 E0 40</code> für einen Float-Wert)</li>
<li><strong>Bestätigung:</strong> Slave antwortet mit <code>RES: DOWNLOAD</code></li>
</ul>
</li>
<li>
<p><strong>Drittes Paket (Optional):</strong></p>
<ul>
<li><strong>Kommando:</strong> <code>SHORT_UPLOAD</code> zur Überprüfung</li>
<li><strong>Bestätigung:</strong> Slave bestätigt mit <code>RES: SHORT_UPLOAD</code></li>
</ul>
</li>
</ol>
<p><strong>Trace-Darstellung:</strong></p>
<p>In einer Trace-Darstellung (Bild 18) würde die Kommunikation wie folgt visualisiert:</p>
<pre><code>Master → Slave: SET_MTA (Adresse: 001C002C, Extension: 0)
Slave → Master: RES: SET_MTA
Master → Slave: DOWNLOAD (Wert: 00 00 E0 40, Länge: 4)
Slave → Master: RES: DOWNLOAD
Master → Slave: SHORT_UPLOAD
Slave → Master: RES: SHORT_UPLOAD
</code></pre>
<p><strong>Überprüfung und Bestätigung:</strong></p>
<p>Durch den abschließenden <code>SHORT_UPLOAD</code> kann der Master sicherstellen, dass der Parameter erfolgreich geändert wurde, indem er den neuen Wert ausliest und mit dem gesetzten Wert vergleicht.</p>
<h5 id="52-dauerhafte-speicherung-von-parametern"><a class="header" href="#52-dauerhafte-speicherung-von-parametern">5.2 Dauerhafte Speicherung von Parametern</a></h5>
<p>Die geänderten Parameter im RAM des Steuergerätes sind nach einem Neustart verloren, da der RAM flüchtig ist. Daher müssen die Änderungen dauerhaft gespeichert werden. Es gibt zwei Hauptansätze:</p>
<h6 id="a-speicherung-im-steuergerät"><a class="header" href="#a-speicherung-im-steuergerät">A) Speicherung im Steuergerät</a></h6>
<ol>
<li>
<p><strong>EEPROM oder Flash:</strong></p>
<ul>
<li><strong>EEPROM:</strong> Nicht-flüchtiger Speicher, der Änderungen automatisch oder manuell speichern kann. Vorteilhaft für kleine Datenmengen, aber bei großen Parametern oft unpraktisch.</li>
<li><strong>Flash:</strong> Größerer Speicherplatz, aber komplexer in der Handhabung, da Flash-Speicher blockweise gelöscht und neu beschrieben werden muss.</li>
</ul>
</li>
<li>
<p><strong>Verfahren:</strong></p>
<ul>
<li><strong>Automatische Speicherung:</strong> Beim Herunterfahren des Steuergeräts.</li>
<li><strong>Manuelle Speicherung:</strong> Durch Benutzerinteraktion.</li>
</ul>
</li>
</ol>
<p><strong>Herausforderungen:</strong></p>
<ul>
<li>Begrenzter Speicherplatz im EEPROM.</li>
<li>Komplexität beim Schreiben in Flash-Speicher, insbesondere bei großen Datenmengen und der Notwendigkeit, Prüfsummen korrekt zu berechnen.</li>
</ul>
<h6 id="b-speicherung-auf-dem-computer"><a class="header" href="#b-speicherung-auf-dem-computer">B) Speicherung auf dem Computer</a></h6>
<ol>
<li>
<p><strong>Parametersatzdateien:</strong></p>
<ul>
<li><strong>Formate:</strong> ASCII-Textdateien, C- oder H-Files, Hex-Files.</li>
<li><strong>Inhalte:</strong> Namen und Werte der Parameter, sowie optionale Metadaten wie Reifegrad oder Historie.</li>
</ul>
</li>
<li>
<p><strong>Vorgehensweise:</strong></p>
<ul>
<li><strong>Speichern:</strong> Geänderte Parameter werden auf dem Computer abgelegt.</li>
<li><strong>Wiederherstellen:</strong> Beim Neustart des Steuergeräts werden die Parameter aus der Datei per <code>DOWNLOAD</code>-Kommando in den RAM des Slaves übertragen.</li>
</ul>
</li>
<li>
<p><strong>Vorteile:</strong></p>
<ul>
<li>Flexibilität und Skalierbarkeit, da große Parametermengen effizient verwaltet werden können.</li>
<li>Einfachere Handhabung und Integration in Arbeitsprozesse, insbesondere ohne Zugriff auf den Quellcode des Steuergeräts.</li>
</ul>
</li>
<li>
<p><strong>Beispiel-Szenario:</strong></p>
<ul>
<li><strong>Speicherung:</strong> Ein Applikateur speichert nach Abschluss der Arbeit die geänderten Parameter in einer Datei.</li>
<li><strong>Wiederherstellung:</strong> Am nächsten Tag lädt der Applikateur die Datei wieder in den Slave, sodass die vorherigen Änderungen fortgesetzt werden können.</li>
</ul>
</li>
</ol>
<p><strong>Abbildung 19: Übertragung einer Parametersatzdatei</strong></p>
<pre><code>Parametersatzdatei (Computer) → Master → Slave: DOWNLOAD (Parameterwerte)
Slave → Master: RES: DOWNLOAD
</code></pre>
<p><strong>Flashen der Parameter:</strong></p>
<ol>
<li>
<p><strong>Hex-Files:</strong></p>
<ul>
<li><strong>Erstellung:</strong> Parameterdateien werden in Hex-Files umgewandelt.</li>
<li><strong>Integration:</strong> Die Hex-Files werden in das bestehende Flash-File integriert, unter Berücksichtigung der Adressen und Werte.</li>
<li><strong>Prüfsummen:</strong> Korrekte Berechnung und Einfügung der Prüfsummen ist entscheidend für die erfolgreiche Flash-Programmierung.</li>
</ul>
</li>
<li>
<p><strong>Prozessschritte:</strong></p>
<ul>
<li><strong>Kopieren:</strong> Die Parameterdatei wird in das Flash-File kopiert.</li>
<li><strong>Verarbeitung:</strong> Eventuell notwendige zusätzliche Schritte zur Erstellung eines flashbaren Files.</li>
<li><strong>Flashen:</strong> Das aktualisierte Flash-File wird in das Steuergerät geschrieben.</li>
</ul>
</li>
</ol>
<p><strong>Herausforderungen:</strong></p>
<ul>
<li>Längere Erstellungszeiten für flashbare Hex-Files.</li>
<li>Notwendigkeit der genauen Adressierung und Prüfsummenberechnung.</li>
<li>Einschränkungen bei der Verfügbarkeit des Quellcodes.</li>
</ul>
<hr />
<h4 id="6-zusammenfassung-und-best-practices"><a class="header" href="#6-zusammenfassung-und-best-practices">6. Zusammenfassung und Best Practices</a></h4>
<p>Die effektive Nutzung der RES, ERR, EV und SERV Mechanismen sowie die sorgfältige Verwaltung von Parametern sind essenziell für eine robuste und flexible XCP-Implementierung. Hier einige Best Practices:</p>
<ul>
<li><strong>Klare Fehlerbehandlung:</strong> Implementieren Sie umfassende ERR-Nachrichten und behandeln Sie Fehler systematisch, um die Stabilität der Kommunikation zu gewährleisten.</li>
<li><strong>Ereignismanagement:</strong> Nutzen Sie EV-Nachrichten für kritische Systemereignisse, um proaktive Überwachungs- und Reaktionsmechanismen zu etablieren.</li>
<li><strong>Service Requests:</strong> Verwenden Sie SERV-Nachrichten, um notwendige Service-Aktionen automatisch zu initiieren und die Systemintegrität aufrechtzuerhalten.</li>
<li><strong>Parameterverwaltung:</strong> Bevorzugen Sie die Speicherung von Parametern auf dem Computer, um Flexibilität und Skalierbarkeit zu maximieren. Nutzen Sie Flash-Speicher nur, wenn unbedingt erforderlich und die Komplexität beherrschbar ist.</li>
<li><strong>Dokumentation:</strong> Halten Sie eine umfassende Dokumentation der verwendeten Parameter und Kommunikationsabläufe bereit, um Wartung und Erweiterungen zu erleichtern.</li>
</ul>
<hr />
<h4 id="fazit-1"><a class="header" href="#fazit-1">Fazit</a></h4>
<p>Die erweiterten Kommunikationsmechanismen von ASAM XCP, einschließlich RES, ERR, EV und SERV, bieten eine robuste Grundlage für die Steuerung und Überwachung von Steuergeräten in komplexen Systemen. Die sorgfältige Verwaltung von Parametern, unterstützt durch flexible Speichermethoden, ermöglicht eine präzise Anpassung und Optimierung der Systeme. Ein tiefes Verständnis dieser Mechanismen ist unerlässlich, um das volle Potenzial des XCP-Protokolls auszuschöpfen und eine effiziente Implementierung sicherzustellen. Durch die Anwendung bewährter Methoden und die Berücksichtigung der beschriebenen Herausforderungen können Entwickler und Ingenieure die Leistungsfähigkeit ihrer Mess- und Kalibrieranwendungen signifikant steigern.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../01_Grundlagen/02_xcp-protokollschicht.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../01_Grundlagen/04_austausch_dto.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../01_Grundlagen/02_xcp-protokollschicht.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../01_Grundlagen/04_austausch_dto.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
